# -*- Python -*- vim: set ft=python ts=4 sw=4 expandtab tw=79:
# Configuration file for the 'lit' test runner.

import os
import lit.formats

config.name = f"MUST-{os.environ.get('LIT_MUST_VERSION', '')}"

config.suffixes = ['.c', '.cpp']
config.excludes = ['must_temp']
config.test_format = lit.formats.ShTest()

config.environment = os.environ

config.environment["MPICH_CC"] = os.environ["MPICH_CC"]
config.environment["MPICH_CXX"] = os.environ["MPICH_CXX"]
config.environment["PATH"] = os.environ["PATH"]
config.environment["MUST_TIMEOUT"] = "5"
config.environment["MUST_OUTPUT"] = "stdout"

if "LIT_MUST_VERSION" in os.environ:
    config.substitutions.append(("%must-version", os.environ["LIT_MUST_VERSION"]))
    config.substitutions.append(("%omp-layout", f"layout_{os.environ['LIT_MUST_VERSION']}.xml"))

config.substitutions.append(("%root-dir", os.path.dirname(__file__)))

config.substitutions.append(
    ("%filecheck",
     "FileCheck --dump-input=always")
)



# import os
# import lit.formats
# from lit.TestingConfig import TestingConfig

# config: TestingConfig

# # Tell pylint that we know config and lit_config exist somewhere.
# if 'PYLINT_IMPORT' in os.environ:
#     config = object()
#     lit_config = object()


# # name: The name of this test suite.
# config.name = 'MUST'

# # suffixes: A list of file extensions to treat as test files.
# config.suffixes = ['.c', '.cpp', '.f', '.sh']

# config.excludes = []

# # Exclude old tests if not explictly enabled
# if not config.enable_old_tests:
#     config.excludes.append("old-tests")
# if config.disable_umpire_tests:
#     config.excludes.append("old-tests/umpireTests")
# if config.disable_marmot_tests:
#     config.excludes.append("old-tests/MarmotTests")

# if "MUST_FAST_TESTS_ONLY" in os.environ or config.fast_tests_only:
#     print("lit.cfg: Selecting only tests that support the fast-tests feature.")
#     config.available_features.add("fast-tests")

# # test_source_root: The root path where tests are located.
# config.test_source_root = os.path.dirname(__file__)

# # test_exec_root: The root object directory where output is placed
# config.test_exec_root = config.builddir + "/tests"

# # test format
# config.test_format = lit.formats.ShTest()

# # Environment variables that should be inherited
# environment_allowlist = [
#     "INTEL_LICENSE_FILE",  # to run with icc INTEL_LICENSE_FILE must be set
#     "OMP_NUM_THREADS",
#     "PSM2_MULTI_EP",  # must be set to avoid PSM2 issues under oversubscription
#     "HOSTNAME",  # the mpiexec-wrapper on claix-18 needs the HOSTNAME environment variable
#     "FI_PROVIDER_PATH",
#     "UCX_TLS",
#     "HOME",
# ]
# environment_allowprefixes = [
#     "I_MPI_",
#     "FI_",
#     "MPIR_CVAR_",
#     "OMPI_MCA_",
#     "INTERNAL_",
# ] 
# if config.pass_prefixed_variables:
#     environment_allowprefixes += config.pass_prefixed_variables.split(";")

# for envvar in os.environ:
#     if config.forward_full_env:
#         config.environment[envvar] = os.environ[envvar]
#         continue
#     if envvar in environment_allowlist:
#         config.environment[envvar] = os.environ[envvar]
#         continue
#     for prefix in environment_allowprefixes:
#         if envvar.startswith(prefix):
#             config.environment[envvar] = os.environ[envvar]
#             break

# # pass all currently set environment variables that contain the word "MPI"
# config.environment.update({k: v for k, v in os.environ.items() if "MPI" in k})

# # non-forwarded environment variables are passed using a substitution.
# # This way they appear in lit's output and are set when copy-pasting
# # the command line from there for debugging.
# envvars = {
#     "INTERNAL_MUST_PREBUILD_PATH": config.test_prebuild_path,
#     "PNMPI_LIB_PATH": config.test_lib_path,
# }

# # This is not a parameter for mustrun.
# if os.environ.get("MUST_FAST_TESTS_ONLY"):
#     del os.environ["MUST_FAST_TESTS_ONLY"]


# if "LIT_MUST_OMP_LAYOUT" in os.environ:
#     config.substitutions.append(("%omp-layout", os.environ["LIT_MUST_OMP_LAYOUT"]))
# #     if os.environ["LIT_MUST_OMP_LAYOUT"] == 

# # Set default mustrun parameters
# default_envvars = [
#     ("MUST_OUTPUT", "stdout"),
#     ("MUST_MPIEXEC", config.mpiexec),
#     ("MUST_TIMEOUT", "20"),
#     ("MUST_TEMP", "%t/must_temp"),
#     ("MUST_USER_CACHE_DIR", "%t/cache"),
# ]
# # --must:clean is controlled by CMake cache variables
# if not config.disable_must_clean:
#     default_envvars.append(("MUST_CLEAN", "1"))

# if config.stacktrace:
#     default_envvars.append(("MUST_STACKTRACE", "backward"))

# for k, v in default_envvars:
#     if not os.environ.get(k):
#         envvars[k] = v

# # Forward MUST environment arguments from caller that override the defaults
# for key, val in os.environ.items():
#     if key.startswith("MUST_"):
#         envvars[key] = val

# config.available_features.add(f"compiler={config.compiler_id.lower()}")
# if config.gti_is_thread_safe and config.openmp_found:
#     config.available_features.add("hybrid")
# if config.ompt_found:
#     config.available_features.add("ompt")
# if "hybrid" in config.available_features and config.enable_tsan:
#     config.available_features.add("tsan")
# # Add feature-tested MPI features
# for k,v in config.lit_features.items():
#     if v:
#         config.available_features.add(k)
        
# if config.mpi_has_assertions:
#     config.available_features.add("mpi_has_assertions")
# if config.have_typeart:
#     config.available_features.add("typeart")
#     config.substitutions.append(("%typeart-mpicc", config.typeart_mpicc))
# if config.stacktrace:
#     config.available_features.add("stacktrace")

# if config.mpi_c_version:
#     config.mpi_version = config.mpi_c_version.split(".")[0]
#     config.mpi_version_minor = config.mpi_c_version.split(".")[1]
#     if int(config.mpi_version) >= 4:
#         config.available_features.add("mpi_has_four_support")

# # These must be added before the main %must-run substitution to have precedence over it. Otherwise the main one will
# # replace the `%must-run` prefix.
# config.substitutions.append(("%must-run-hybrid", "env MUST_HYBRID=1 %must-run"))
# config.substitutions.append(("%must-run-tsan", "env MUST_TSAN=1 %must-run"))
# config.substitutions.append(("%must-run-ddl", "env MUST_DISTRIBUTED=1 MUST_DL=1 MUST_FANIN=2 %must-run"))

# config.substitutions.append(("%must-run", f"%envvars bash {config.test_mustrun} --must:np {config.mpiexec_numproc_flag}"))

# # Use a substitution such that these will appear in lit's test output.
# envvar_string = " ".join(f"{key}=\"{value}\"" for key, value in envvars.items())
# config.substitutions.append(("%envvars", f"env {envvar_string}"))

# # Use tee to tap and save the MUST output passed to FileCheck. The file is
# # written to the cmake build directory. It is placed in the directory
# # corresponding to the source file as `<testsource_basename>.filecheck.in`.
# filecheck_wiretap = "tee %basename_t.filecheck.in | "
# filecheck_cmd = (filecheck_wiretap
#                  + config.test_filecheck
#                  + " --dump-input always")
# config.substitutions.append(
#     ("%filecheck-may-segfault", filecheck_cmd)
# )
# config.substitutions.append(
#     ("%filecheck",
#      filecheck_cmd + " --implicit-check-not 'Caught signal {{6|11}}' --implicit-check-not 'caught signal nr {{6|11}}'")  # noqa: E501
# )

# if config.stacktrace:
#     check_prefix_opt = "--check-prefixes CHECK,CHECK-ST"
# else:
#     check_prefix_opt = ""
# config.substitutions.append(
#     ("%check-prefixes", check_prefix_opt)
# )

# config.substitutions.append(("%must-bin-dir", config.must_bin_dir))
# config.substitutions.append(("%builddir", config.builddir))
# config.substitutions.append(("%must-src", config.srcdir))
# config.substitutions.append(("%mpiexec-numproc-flag", config.mpiexec_numproc_flag))
# config.substitutions.append(("%not", config.not_helper_script))
